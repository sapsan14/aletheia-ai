# Подпись в Aletheia AI

**Цифровые подписи делают вывод ИИ атрибутируемым и защищённым от подделки.**

В этом документе описано, как подпись интегрирована в backend Aletheia: что подписываем, управление ключом, обработка ошибок, тестирование, хранение и скоуп.

---

## Содержание

- [Что мы подписываем](#что-мы-подписываем)
- [Управление ключом](#управление-ключом)
- [Интерфейс и алгоритм](#интерфейс-и-алгоритм)
- [Обработка ошибок](#обработка-ошибок)
- [Стратегия тестирования](#стратегия-тестирования)
- [Модель хранения](#модель-хранения)
- [Безопасность и скоуп](#безопасность-и-скоуп)
- [Связанные документы](#связанные-документы)

---

## Что мы подписываем

Мы подписываем **хеш** канонического ответа ИИ, а не сырой текст.

Цепочка:

```
Текст ответа ИИ  →  канонизация  →  хеш (SHA-256)  →  подпись (RSA)
                                                           ↓
                                          байты подписи (используются для метки времени)
```

- **Канонизация** гарантирует, что один и тот же смысл даёт одни и те же байты (Unicode NFC, переносы строк, пробелы).
- **Хеш** (SHA-256) даёт фиксированный дайджест; мы подписываем этот дайджест.
- **Подпись** привязывает дайджест к нашему приватному ключу; TSA затем ставит метку времени на **байты подписи** (см. [Временные метки](TIMESTAMPING.md)).

Мы удостоверяем *что* было сказано; TSA удостоверяет *когда* это было подписано. См. [Модель доверия](TRUST_MODEL.md) и [диаграммы](../../diagrams/architecture.md).

---

## Управление ключом

- **Формат:** PEM (приватный ключ RSA). Генерация через OpenSSL:
  ```bash
  openssl genpkey -algorithm RSA -out ai.key -pkeyopt rsa_keygen_bits:2048
  ```
- **Расположение:** Путь задаётся в `ai.aletheia.signing.key-path` (файл или `classpath:...`). Ключ опционален при старте; sign/verify выдают понятную ошибку, если ключ не загружен.
- **Скоуп PoC:** Достаточно одного ключа; ротация ключей вне скоупа. Без HSM; ключ загружается из файла или classpath.

---

## Интерфейс и алгоритм

- **Подпись:** `sign(hashHex)` или `sign(hashBytes)` → подпись в byte[] или Base64.
- **Проверка:** `verify(hashHex, signatureBase64)` или `verify(hashBytes, signatureBytes)` → boolean.

Алгоритм: **RSA с SHA-256** (PKCS#1 v1.5, DigestInfo). Реализация на BouncyCastle; публичный ключ для проверки получается из приватного.

Сервис **нейтрален**: подписывает и проверяет байтовые дайджесты. В пайплайн передаётся хеш канонического ответа; AI-специфичных типов в интерфейсе нет.

---

## Обработка ошибок

`SignatureService` должен обрабатывать:

- **ключ не настроен** (пустой путь или отсутствующий файл) — падать при первом sign/verify с понятным сообщением;
- **невалидный ввод** (null-хеш, неверная длина, не hex) — `IllegalArgumentException`;
- **ошибка загрузки ключа** (битый PEM, неподдерживаемый формат) — падать при загрузке или первом использовании; задокументировать в Javadoc.

Выбранное поведение (опциональный ключ при старте или обязательный) задокументировано в коде и README.

---

## Стратегия тестирования

- **Юнит-тесты:** In-memory пара ключей RSA (без PEM-файла) или тестовый PEM в `src/test/resources` с `classpath:test-signing-key.pem`. Тесты: подпись и проверка успешны; подделанная подпись → false; невалидный ввод → исключение.
- **CI:** Внешний ключ не нужен; тесты используют in-memory ключи или закоммиченный тестовый PEM (только для тестов).
- **Интеграция:** При запуске приложения с реальным путём к ключу sign/verify используют этот ключ; отдельного «сервера подписи» нет.

---

## Модель хранения

Подпись хранится вместе с:

- ответом ИИ (текст),
- хешем ответа (SHA-256, hex или байты),
- токеном временной метки (непрозрачные байты — см. [Временные метки](TIMESTAMPING.md)),
- метаданными (модель, параметры, время).

Пример поля в БД:

```sql
signature BYTEA
```

Подпись **неизменяема** и не должна изменяться после сохранения.

---

## Безопасность и скоуп

Этот PoC **намеренно**:

- не реализует квалифицированную электронную подпись (QES) по eIDAS;
- не использует HSM или ключевую церемонию;
- использует **один** ключ; ротация вне скоупа.

**Архитектура** сделана так, чтобы тот же пайплайн можно было в будущем подключить к квалифицированным поставщикам доверенных услуг и к подписанию, совместимому с eIDAS (см. [Модель доверия — eIDAS](TRUST_MODEL.md#eidas-неквалифицированное--квалифицированное)).

---

## Связанные документы

- [Временные метки](TIMESTAMPING.md) — что метим по времени (байты подписи), TSA, хранение.
- [Модель доверия](TRUST_MODEL.md) — цепочка доверия, кто что удостоверяет, соответствие eIDAS.
- [Crypto reference (EN)](../en/CRYPTO_REFERENCE.md) — алгоритмы, ключи, почему tsaToken (на англ.).
- [Диаграммы архитектуры](../../diagrams/architecture.md) — пайплайн и крипто-слой.
- [README](../../README.md) — обзор дизайна, инструкции по запуску.
