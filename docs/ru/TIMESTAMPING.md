# Временные метки в Aletheia AI

**Метки времени RFC 3161 делают вывод ИИ доказуемым во времени.**

В этом документе описано, как временные метки интегрированы в backend Aletheia: варианты TSA endpoint, обработка ошибок, стратегия тестирования, хранение и скоуп.

---

## Содержание

- [TSA Endpoint](#tsa-endpoint)
- [Обработка ошибок](#обработка-ошибок)
- [Стратегия тестирования](#стратегия-тестирования)
- [Модель хранения](#модель-хранения)
- [Безопасность и скоуп](#безопасность-и-скоуп)
- [Концептуальное резюме](#концептуальное-резюме)
- [Будущие работы (вне скоупа)](#будущие-работы-вне-скоупа)
- [Итог](#итог)
- [Связанные документы](#связанные-документы)

---

## TSA Endpoint

Endpoint TSA (Time-Stamp Authority) **внешний** по отношению к backend. Он может быть:

- **локальным RFC 3161 сервером** (например OpenTSA, OpenSSL TSA)
- **тестовой заглушкой** (детерминированный mock для юнит-тестов и CI)
- **публичной TSA** (будущее)
- **eIDAS-квалифицированной TSA** (будущее)

Backend отправляет запросы метки времени на настроенный URL и сохраняет возвращённый токен как непрозрачные байты.

### Переключение MOCK_TSA / REAL_TSA

- **mode=mock** (по умолчанию) → MockTsaServiceImpl, без сети, детерминированный
- **mode=real** → RealTsaServiceImpl, HTTP POST на `AI_ALETHEIA_TSA_URL`

Конфиг: `ai.aletheia.tsa.mode`, `ai.aletheia.tsa.url`. Варианты реального TSA: публичные (DigiCert, Sectigo), локальные (OpenTSA), eIDAS. Подробности: [docs/en/TIMESTAMPING.md](../en/TIMESTAMPING.md#switching-mock_tsa--real_tsa).

---

## Обработка ошибок

`TimestampService` должен обрабатывать:

- **сбои соединения** (таймаут, недоступный хост)
- **невалидные ответы TSA** (не 2xx, неверный content type)
- **битые токены** (непарсируемые байты)

Реализация может выбрать либо:

- **проверяемые или runtime-исключения** (fail fast, обрабатывает вызывающий), либо  
- **ответы в стиле Optional** (например `Optional<byte[]>` или тип `Result`)

Выбранный подход должен быть **чётко задокументирован в коде** (например в интерфейсе сервиса и Javadoc реализации).

---

## Стратегия тестирования

Поддерживаются два режима тестирования.

### 1. Mock / Stub TSA (по умолчанию для юнит-тестов)

Детерминированная заглушка может возвращать:

- фиксированную последовательность байт, либо  
- воспроизводимый mock-токен

Используется для:

- быстрых юнит-тестов  
- CI (внешняя TSA не нужна)  
- изолированной проверки логики пайплайна  

### 2. Локальная RFC 3161 TSA (интеграционные тесты)

Опциональное интеграционное тестирование с помощью:

- OpenSSL TSA  
- OpenTSA  
- минимального локального RFC 3161 сервера  

Ожидания тестов:

- возвращается токен метки времени  
- токен **парсится** BouncyCastle  
- время генерации (`genTime`) можно извлечь (и опционально залогировать)  

Сам TSA-сервер **вне скоупа** этой задачи — мы потребляем endpoint, не реализуем его.

---

## Модель хранения

Токен метки времени хранится вместе с:

- ответом ИИ (текст)  
- хешем ответа (SHA-256)  
- цифровой подписью  
- метаданными (модель, параметры, время)  

Пример поля в БД:

```sql
timestamp_token BYTEA
```

Токен **неизменяем** и не должен изменяться после сохранения.

---

## Безопасность и скоуп

Этот PoC **намеренно**:

- не заявляет юридической силы  
- не реализует квалифицированные доверенные сервисы  
- не выполняет проверку цепочки сертификатов  

При этом **архитектура** рассчитана на полную совместимость с:

- eIDAS-квалифицированными службами меток времени  
- долгосрочной архивной валидацией  
- регуляторными сценариями аудита  

Тот же пайплайн можно в будущем подключить к квалифицированной TSA без переделки.

---

## Концептуальное резюме

Эта модель временных меток **не** пытается сделать ИИ «правдивым».

Она делает вывод ИИ **доказуемым**.

Система отвечает на один точный вопрос:

> *«Можем ли мы доказать, что этот точный вывод существовал в этот точный момент времени?»*

Эта возможность становится критичной, когда ИИ-системы из чат-инструментов превращаются в автономных агентов, влияющих на реальные решения.

---

## Будущие работы (вне скоупа)

Следующее **намеренно исключено** из PoC, чтобы держать скоуп под контролем:

- сервис **проверки** метки времени  
- интеграция с квалифицированной TSA  
- долгосрочная валидация (LTV)  
- Evidence Record Syntax (ERS / RFC 4998)  
- регуляторные профили доверия  

Они остаются естественными расширениями для следующей фазы.

---

## Итог

Временные метки — не про перенос ответственности.

Они про **сохранение реальности**.

Как только ответ ИИ подписан и помечен временем, историю уже нельзя переписать.

---

## Тестирование с RFC 3161 test vectors

Для тестирования имплементации **RFC 3161 test vectors** и **golden fixtures** предоставляют детерминированные эталонные выходы:

- **Test vectors** = конкретные примеры: данный хеш/дайджест → ожидаемый TSA ответ
- **Golden fixtures** = сохранённые эталонные токены для регрессионного тестирования

**Пример test vector:**

```json
{
  "digest_sha256": "b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9",
  "tst_token_base64": "MIIC...",
  "expected_time": "2026-01-01T00:00:00Z",
  "policy_oid": "1.2.3.4.5.6.7.8"
}
```

**Назначение:**
- Проверить, что RFC 3161 client/server ведёт себя корректно
- Включить валидные случаи и edge cases (невалидные хеши, неправильные алгоритмы)
- Обеспечить побайтовое регрессионное тестирование против known-good выходов

**Источники:**
- BouncyCastle `tsp` test suites
- Open-source TSA имплементации
- Aletheia MOCK_TSA (см. [MOCK_TSA](MOCK_TSA.md))

Для детерминированного тестирования в Aletheia используйте MOCK_TSA для генерации воспроизводимых токенов. См. [Криптографический оракул](CRYPTO_ORACLE.md) для философии тестирования.

---

## Связанные документы

- [Подпись](SIGNING.md) — что мы подписываем; байты подписи — то, что мы метим по времени.
- [Модель доверия](TRUST_MODEL.md) — кто что удостоверяет, соответствие eIDAS.
- [MOCK_TSA](MOCK_TSA.md) — детерминированный TSA для тестирования, RFC 3161 test vectors.
- [Криптографический оракул](CRYPTO_ORACLE.md) — паттерн оракула для тестирования временных меток.
- [Диаграммы архитектуры](../../diagrams/architecture.md) — пайплайн и цепочка доверия.
- [README](../../README.md) — обзор дизайна, инструкции по запуску.
