# Криптографический тестовый оракул

**Детерминированные эталонные выходы для проверки корректности криптографических имплементаций.**

---

## Содержание

- [Что такое криптографический тестовый оракул](#что-такое-криптографический-тестовый-оракул)
- [Зачем нужны криптографические оракулы](#зачем-нужны-криптографические-оракулы)
- [Что оракул есть (и что он не есть)](#что-оракул-есть-и-что-он-не-есть)
- [Пример: оракул временных меток](#пример-оракул-временных-меток)
- [Связь с MOCK_TSA](#связь-с-mock_tsa)
- [Паттерн оракула на практике](#паттерн-оракула-на-практике)
- [Аналогия: видеорегистратор для криптографии](#аналогия-видеорегистратор-для-криптографии)
- [Почему это важно для AI / LLM-агентов](#почему-это-важно-для-ai--llm-агентов)
- [Типы оракулов в Aletheia](#типы-оракулов-в-aletheia)
- [Стратегия имплементации](#стратегия-имплементации)
- [Резюме](#резюме)
- [Связанные документы](#связанные-документы)

---

## Что такое криптографический тестовый оракул

**Криптографический тестовый оракул** — это детерминированный и воспроизводимый эталонный выход, используемый для проверки корректности криптографических имплементаций.

В криптографии многие операции **недетерминированы по дизайну**:

- Цифровые подписи используют случайные nonce (ECDSA, RSA-PSS)
- Временные метки зависят от реального времени
- Источники энтропии различаются в разных системах
- Внешние сервисы (TSA, HSM, LLM) дают переменные результаты
- Схемы padding вводят случайность

Из-за этого традиционные проверки вида:

```java
assertEquals(expected, actual);
```

часто **невозможны** без оракула.

**Оракул определяет, что считается «корректным».**

---

## Зачем нужны криптографические оракулы

Без криптографического оракула тесты обычно деградируют в поверхностные проверки:

```java
// ❌ Слабые тесты без оракула
assertNotNull(response);              // "ответ не null"
assertTrue(token.canBeParsed());      // "токен парсится"
assertTrue(verifySignature(token));   // "подпись верна"
```

Эти проверки валидируют **структуру**, но не **корректность**.

Криптографический оракул позволяет тестировать на более глубоком уровне:

| Уровень теста | Без оракула | С оракулом |
|---------------|-------------|------------|
| **Структура** | ✅ Можно распарсить ASN.1 | ✅ Можно распарсить ASN.1 |
| **Корректность** | ❌ Неизвестно, правильный ли выход | ✅ Побайтовое совпадение с эталоном |
| **Регрессия** | ❌ Изменения незаметны | ✅ Любое изменение ломает тест |
| **Совместимость** | ❌ Нет проверки между версиями | ✅ Один оракул работает для всех версий |

**Преимущества:**

- **Побайтовая воспроизводимость** — точный выход для заданного входа
- **Детерминированная верификация** — один оракул работает вечно
- **Долгосрочная защита от регрессий** — изменения обнаруживаются немедленно
- **Криптографическая совместимость** — гарантирует совместимость имплементаций между версиями

**Это особенно важно для:**

- PKI-систем (X.509, цепочки сертификатов)
- RFC 3161 timestamping
- CMS / ASN.1 структур
- Валидации подписей
- Подписания агентов и audit trail
- Неотказуемых выходов

---

## Что оракул есть (и что он не есть)

### ✅ Оракул — ЭТО:

- **Детерминированный** — одинаковый вход всегда даёт одинаковый выход
- **Воспроизводимый** — можно регенерировать при необходимости
- **Стабильный во времени** — работает сегодня, завтра, через 10 лет
- **Независимый от живых сервисов** — нет сети, нет внешних зависимостей
- **Подходит для CI/CD** — быстрый, надёжный, без флапов

### ❌ Оракул — НЕ:

- **Реальный TSA** — не доказывает реальное время
- **Production CA** — не выдаёт доверенные сертификаты
- **Живой криптографический орган** — не даёт юридических гарантий
- **Граница безопасности** — не для продакшена
- **Замена реальным сервисам** — только для тестирования

**Ключевой принцип:**

> Оракул — это **источник истины для тестов**, а не **якорь доверия**.

---

## Пример: оракул временных меток

### Вход

```
digest = SHA-256("hello world")
       = b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9
```

### Оракул определяет

Оракул хранит **фиксированный RFC 3161 токен временной метки** для этого дайджеста:

```
timestamp_token = BASE64(
  308203a1020101300d06092a864886f70d01010105000482012f...
)
```

Этот токен:

- **Сгенерирован однажды** — детерминированным MOCK_TSA
- **Сохранён как test fixture** — например, `src/test/resources/fixtures/hello-world.tsr`
- **Переиспользуется вечно** — во всех будущих тестах

### Что валидирует оракул

Каждый будущий тест проверяет:

| Аспект | Что проверяет оракул |
|--------|----------------------|
| **Парсинг** | Токен можно распарсить как ASN.1 / RFC 3161 |
| **Структура** | Содержит валидные `TSTInfo`, `SignedData`, `ContentInfo` |
| **Подпись** | Логика верификации подписи работает |
| **Временная метка** | Поле `genTime` соответствует ожидаемому фиксированному времени |
| **Message imprint** | Дайджест совпадает с входом |
| **RFC 3161 compliance** | Все обязательные поля присутствуют |

**Если байты различаются — имплементация изменилась.**

Это сигнал о регрессии: либо была введена ошибка, либо криптографическая библиотека изменила поведение.

---

## Связь с MOCK_TSA

**Концептуальное различие:**

| Концепция | Роль |
|-----------|------|
| **MOCK_TSA** | Механизм имплементации — генерирует детерминированные токены |
| **Криптографический оракул** | Концептуальная роль — определяет, что «корректно» |

**В Aletheia AI:**

1. **MOCK_TSA** генерирует детерминированные токены временных меток (RFC 3161).
2. Эти токены **выступают в роли криптографических оракулов** — они определяют ожидаемые выходы.
3. Тесты валидируют поведение **относительно оракула** (побайтовое сравнение или структурная валидация).

**Пример потока:**

```
Вход (digest) → MOCK_TSA → TimeStampToken (bytes)
                                    ↓
                          Сохранить как оракул
                                    ↓
            Будущие тесты сравнивают с оракулом
```

Это позволяет тестировать логику временных меток **без необходимости**:

- Реального TSA endpoint
- Доступа к сети
- Зависимости от системных часов
- Внешних криптографических сервисов

---

## Паттерн оракула на практике

### 1. Фаза генерации (однократно)

```java
// Сгенерировать оракул один раз
MockTsaService mockTsa = new MockTsaService(fixedKey, fixedCert);
byte[] digest = sha256("hello world");
byte[] oracleToken = mockTsa.respond(createTSQ(digest));

// Сохранить в test resources
Files.write(Paths.get("fixtures/hello-world.tsr"), oracleToken);
```

### 2. Фаза тестирования (повторяется вечно)

```java
@Test
void timestampServiceMatchesOracle() throws Exception {
    // Загрузить оракул
    byte[] expectedToken = loadFixture("hello-world.tsr");
    
    // Сгенерировать токен с тем же входом
    byte[] actualToken = timestampService.timestamp("hello world");
    
    // Сравнить с оракулом
    assertArrayEquals(expectedToken, actualToken);
}
```

**Если тест падает:**

- Либо имплементация изменилась (регрессия)
- Либо оракул нужно обновить (намеренное изменение)

### 3. Многоуровневая валидация

Оракулы можно использовать на разных уровнях:

| Уровень | Валидация |
|---------|-----------|
| **Байтовый** | `assertArrayEquals(expected, actual)` — самый строгий |
| **Структурный** | Распарсить оба, сравнить поля (`genTime`, `serial`, `policy`) |
| **Семантический** | Проверить подпись, хеш, валидировать ASN.1 — самый мягкий |

**Для максимальной защиты от регрессий: использовать байтовый уровень.**

---

## Аналогия: видеорегистратор для криптографии

Криптографический оракул — это как **видеорегистратор** для криптографии.

**Он НЕ решает:**

- Кто виноват
- Что должно было случиться
- Что «правильно» в абстрактном смысле

**Он записывает:**

> «Это **точно** то, что произошло в этот криптографический момент».

Позже имплементации могут быть проверены относительно него:

- Изменился ли выход?
- Совместимо ли новое поведение?
- Можем ли мы воспроизвести тот же результат?

**Оракул — это свидетель, а не судья.**

---

## Почему это важно для AI / LLM-агентов

По мере того как LLM-агенты становятся автономными, они будут:

- Принимать решения
- Генерировать выходы
- Запускать действия
- Взаимодействовать с внешними системами (API, базы данных, пользователи)

Для **аудируемости** и **разделения ответственности** становится критичным знать:

| Вопрос | Почему это важно |
|--------|------------------|
| **Что сказал агент?** | Содержание ответа |
| **Когда он это сказал?** | Временная метка (неотказуемая) |
| **При каком model/config?** | Контекст: версия модели, temperature, prompt |
| **Можно ли переписать историю?** | Нет — криптографическое доказательство |

### Криптографические оракулы обеспечивают:

1. **Детерминированный replay** — воспроизвести точный выход агента в тестах
2. **Верифицируемые audit logs** — доказать, что агент сказал и когда
3. **Неотказуемые выходы агента** — агент не может отрицать прошлые утверждения
4. **Долгосрочная подотчётность** — audit trail выживает годами

### Пример: оракул выхода агента

```
Вход:
  prompt = "Резюмируй контракт X"
  model  = "gpt-4"
  
Оракул:
  response     = "Контракт X гласит..."
  signature    = 0x4a3f2e...
  timestamp    = 2026-01-01T00:00:00Z (TSA токен)
  
Тест:
  replay(prompt, model) → должен совпасть с оракулом response
```

Это гарантирует:

- Поведение агента воспроизводимо
- Тесты ловят непреднамеренные изменения модели
- Audit trail защищён от подделок

**Для Aletheia AI:** Каждый подписанный и проштампованный LLM-ответ может служить оракулом для регрессионного тестирования и верификации аудита.

---

## Типы оракулов в Aletheia

| Тип оракула | Назначение | Пример fixture |
|-------------|------------|----------------|
| **Оракул канонизации** | Проверить нормализацию текста | `canonical-text.txt` |
| **Оракул хеша** | Проверить выход SHA-256 | `hash-golden.bin` (32 байта) |
| **Оракул подписи** | Проверить подпись RSA PKCS#1 v1.5 | `signature-golden.sig` |
| **Оракул временной метки** | Проверить RFC 3161 токен | `timestamp-golden.tsr` |
| **RFC 3161 test vector** | Полная пара TSQ/TSR для тестирования протокола | `test-vector.json` + файлы `.tsq`/`.tsr` |
| **Оракул LLM-ответа** | Проверить выход агента (для детерминированных моделей) | `llm-response-golden.json` |

Каждый оракул живёт в `src/test/resources/fixtures/` и версионируется в Git.

**Примечание о RFC 3161 test vectors:** В отличие от простых golden fixtures (один выходной файл), test vectors включают как вход (`TimeStampRequest` / `.tsq`), так и ожидаемый выход (`TimeStampResponse` / `.tsr`), плюс метаданные (ожидаемое время, serial, policy OID). Они используются для тестирования полного соответствия протоколу RFC 3161, а не только воспроизводимости выхода. См. [MOCK_TSA](MOCK_TSA.md) для деталей о генерации test vectors с помощью детерминированного MOCK_TSA.

---

## Стратегия имплементации

### Шаг 1: Сгенерировать оракулы

Используйте детерминированные имплементации (MOCK_TSA, фиксированные ключи, фиксированное время) для генерации эталонных выходов:

```java
MockTsaService mockTsa = new MockTsaService(fixedKey, fixedCert);
byte[] oracle = mockTsa.respond(tsq);
saveFixture("oracle.tsr", oracle);
```

### Шаг 2: Сохранить в репозитории

```
backend/src/test/resources/fixtures/
  ├── canonical-text-1.txt
  ├── hash-golden-1.bin
  ├── signature-golden-1.sig
  └── timestamp-golden-1.tsr
```

Закоммитить в Git — оракулы становятся частью кодовой базы.

### Шаг 3: Написать тесты

```java
@Test
void matchesOracle() {
    byte[] expected = loadFixture("oracle.tsr");
    byte[] actual = service.process(input);
    assertArrayEquals(expected, actual);
}
```

### Шаг 4: Поддерживать оракулы

- **При намеренном изменении** (обновление алгоритма, upgrade библиотеки): регенерировать оракул и закоммитить.
- **При случайном изменении** (баг, регрессия): тест падает → исправить код, а не оракул.

**Золотое правило:** Оракул должен меняться только тогда, когда вы **намеренно** меняете криптографическое поведение.

---

## Резюме

Криптографические тестовые оракулы обеспечивают:

| Преимущество | Описание |
|--------------|----------|
| **Детерминированная верификация** | Одинаковый вход всегда даёт одинаковый выход |
| **Воспроизводимое тестирование** | Тесты работают вечно, без флапов |
| **Криптографическая уверенность** | Побайтовая корректность, а не только структура |
| **Будущеустойчивый контроль регрессий** | Любое изменение обнаруживается немедленно |

**Они являются фундаментом для построения заслуживающих доверия систем, включающих:**

- **PKI** (сертификаты, подписи, цепочки)
- **Timestamping** (RFC 3161, TSA)
- **Подписание** (RSA, ECDSA, подпись контента)
- **Автономные AI-агенты** (audit trail, неотказуемость, подотчётность)

**Для Aletheia AI:** Криптографические оракулы гарантируют, что каждый компонент (канонизация, хеширование, подписание, временные метки, LLM-ответы) тестируется относительно детерминированных эталонных выходов, обеспечивая долгосрочную аудируемость и верифицируемость.

---

## Связанные документы

- [MOCK_TSA](MOCK_TSA.md) — Детерминированная имплементация TSA для генерации оракулов временных меток
- [Временные метки (TIMESTAMPING)](TIMESTAMPING.md) — RFC 3161, TSA endpoint, что метим по времени
- [Подпись (SIGNING)](SIGNING.md) — RSA PKCS#1 v1.5, детерминированные подписи
- [Модель доверия (TRUST_MODEL)](TRUST_MODEL.md) — Кто что удостоверяет, соответствие eIDAS
- [План имплементации (PLAN)](PLAN.md) — Задача 2.4: TimestampService (где используются оракулы)
- [Архитектурные диаграммы](../../diagrams/architecture.md) — Pipeline с крипто-слоем и цепочкой доверия
- [README](../../README.md) — Обзор проекта, дизайн, инструкции по запуску

---

**Статус:** Концептуальный документ. Тестирование на основе оракулов запланировано для Task 2.4 (TimestampService) и далее.

**Лицензия:** MIT (в соответствии с проектом Aletheia AI).
