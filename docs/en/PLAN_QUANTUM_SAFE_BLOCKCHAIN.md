# Aletheia AI -- Quantum-Safe Blockchain Plan (LLM Response Ledger)

This plan describes how to build a **quantum-safe blockchain** that records **LLM request/response evidence** generated by users. The ledger is designed to be **append-only**, **auditable**, and **future-proof** with **post-quantum signatures**. It reuses the existing Aletheia signing and Evidence Package pipeline as the **final step** of the flow.

Status: Draft (implementation plan + UI guidance)

---

## Goals

1. **Capture LLM responses from user prompts** and turn them into immutable ledger entries.
2. **Preserve verification data** (hashes, signatures, timestamps, Evidence Package).
3. **Add quantum-safe cryptography** (ML-DSA / Dilithium) for long-term validity.
4. **Anchor to external time sources** (RFC 3161 TSA) and optional public chain anchors.
5. **Make the process visible** in a readable UI and LLM-friendly instructions.

## Non-goals

- Replacing existing RSA + TSA flow. This plan **adds** a quantum-safe ledger on top.
- Building a public cryptocurrency. This is a **private, auditable ledger**.
- Storing raw prompts or PII on-chain. Store hashes and metadata only.

---

## High-level architecture

```
User Prompt
  -> LLM Response
     -> Canonicalize
        -> Hash (SHA-256)
           -> Classical signature + TSA
           -> PQC signature (ML-DSA)
              -> Evidence Package (.aep)
                 -> Ledger block (QSB chain)
                    -> Optional external anchor (public chain)
```

**Reuse existing functionality as final step:**
the Evidence Package and verification UI are the last step in the pipeline.

---

## Ledger data model

### Block (QSB-Block)

```
block_id: integer
previous_hash: hex
block_hash: hex
created_at: ISO-8601
merkle_root: hex
transactions: [QSB-Tx...]
block_signature_classical: base64
block_signature_pqc: base64
tsa_token: base64
anchor: { provider, tx_id, block_height } (optional)
```

### Transaction (QSB-Tx) -- one LLM response

```
tx_id: string
response_hash: hex
evidence_hash: hex (hash of .aep file)
llm_model: string
policy_version: string
request_id: string (optional)
claim_hash: hex (optional)
created_at: ISO-8601
```

---

## Implementation plan (LLM-readable tasks)

Each task includes LLM-friendly prompts and acceptance criteria.

### QSB.1 -- Capture and canonicalize LLM response

**Goal:** reuse existing canonicalization for all ledger entries.

**LLM instructions:**
- Use the current canonicalization logic (backend + frontend parity).
- The canonical text is the source for hashing and both signatures.
- Persist `response_hash` for each response.

**Acceptance:**
- Canonicalization output is identical to current pipeline.
- Hash is deterministic across clients.

### QSB.2 -- Evidence Package hash

**Goal:** hash the Evidence Package (.aep) and attach it to the ledger entry.

**LLM instructions:**
- After creating .aep, compute `evidence_hash = SHA-256(.aep bytes)`.
- Store it alongside `response_hash` in ledger transaction metadata.

**Acceptance:**
- Same .aep yields same `evidence_hash`.
- Hash is stored and returned in the ledger API.

### QSB.3 -- PQC block signatures (ML-DSA)

**Goal:** sign block headers with PQC keys.

**LLM instructions:**
- Use ML-DSA (Dilithium) keys from the PQC plan.
- Sign the `block_hash` with PQC private key.
- Store `block_signature_pqc` and `pqc_public_key` in metadata.

**Acceptance:**
- PQC signature verifies for each block.
- No PQC key configured -> block still valid with classical signature only.

### QSB.4 -- Ledger storage (append-only)

**Goal:** create a tamper-evident, append-only chain.

**LLM instructions:**
- Each block must include `previous_hash`.
- `block_hash` = SHA-256(block_header_json_canonical).
- Reject block creation if `previous_hash` mismatch.

**Acceptance:**
- Block chain is verifiable end-to-end.
- Any modification breaks hash chain.

### QSB.5 -- Anchor to external chain (optional)

**Goal:** optional public chain anchor for proof-of-existence.

**LLM instructions:**
- After block creation, optionally send `block_hash` to an anchor service.
- Store `anchor.provider`, `anchor.tx_id`, `anchor.block_height`.
- If anchor fails, ledger still stores block without anchor.

**Acceptance:**
- Anchor metadata stored when service is enabled.
- Failure does not block block creation.

### QSB.6 -- API endpoints

**Goal:** expose ledger data.

**LLM instructions:**
- Add `GET /api/ledger/blocks` (paginated).
- Add `GET /api/ledger/blocks/{id}` with full block.
- Add `GET /api/ledger/tx/{tx_id}` for single response entry.

**Acceptance:**
- Endpoints return blocks/tx with response_hash and evidence_hash.

### QSB.7 -- UI: Ledger Timeline

**Goal:** a readable UI showing the chain and how the flow works.

**LLM instructions:**
- Build a new UI page with a timeline of steps.
- Show block and transaction structure in a clean card layout.
- Highlight the final step: "Use existing Send and Verify flow".

**Acceptance:**
- Page exists and is linked from the home dashboard.
- UI describes the chain and links to the existing verification page.

### QSB.8 -- LLM-readable runbook

**Goal:** provide instructions for an LLM to implement features safely.

**LLM instructions:**
- Include a clear, structured runbook section in the docs/UI.
- Use short, numbered steps and explicit input/output artifacts.
- Ensure each step has a testable expected output.

**Acceptance:**
- Runbook section is present and readable as plain text.

### QSB.9 -- Final step: reuse existing verification pipeline

**Goal:** preserve current trust proof as the final step.

**LLM instructions:**
- The chain entry links to the existing response id.
- Use the existing Evidence Package (.aep) and verifier.
- UI must point users to "Send and Verify" as the final action.

**Acceptance:**
- Users can complete the flow using existing UI and verifier.

---

## ASTROS test plan

ASTROS = Acceptance, Security, Traceability, Reliability, Observability, Scalability

| Category | Purpose | Example tests | Expected result |
|----------|---------|---------------|-----------------|
| A (Acceptance) | User value and flow success | Create response, add to ledger, verify | Full flow succeeds with evidence |
| S (Security) | Tamper resistance | Modify block data, verify chain | Verification fails on tampering |
| T (Traceability) | Link to evidence | Fetch tx and evidence hash | Hash matches .aep file |
| R (Reliability) | Resilience to failures | Anchor fails, chain still writes | Block exists without anchor |
| O (Observability) | Auditable logs | Event logged per block/tx | Log contains block_id and hash |
| S (Scalability) | Growth and load | 10k tx batch, query pages | Pagination works, no timeouts |

---

## UI plan (summary)

1. **Timeline view** of steps (prompt -> response -> evidence -> block -> anchor).
2. **Block and transaction cards** with fields and short explanations.
3. **LLM runbook** as a copyable text block.
4. **Final action button** that opens the existing Send and Verify flow.

---

## Completion criteria

- New plan doc exists (this file).
- New UI page exists and is linked from the home page.
- ASTROS test plan is documented.
- Final step explicitly reuses existing verification pipeline.

---

## References

- docs/en/PLAN_PQC.md (PQC hybrid signing)
- docs/en/PLAN_PHASE5.md (blockchain anchoring, integrations)
- docs/en/SIGNING.md (current signing flow)
- docs/en/TIMESTAMPING.md (RFC 3161)
